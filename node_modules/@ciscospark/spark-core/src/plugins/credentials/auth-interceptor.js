/**!
 *
 * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.
 */

import {Interceptor} from '@ciscospark/http-core';

export default class AuthInterceptor extends Interceptor {
  constructor(spark) {
    super();

    if (!spark) {
      throw new Error(`\`spark\` is a required parameter`);
    }

    Reflect.defineProperty(this, `spark`, {
      enumerable: false,
      value: spark
    });
  }

  static create() {
    return new AuthInterceptor(this);
  }

  onRequest(options) {
    // If Authorizations is already set, don't overwrite it
    if (`authorization` in options.headers) {
      // If Authorization is set to null, false, or undefined, delete it to
      // prevent a CORS preflight.
      if (!options.headers.authorization) {
        Reflect.deleteProperty(options.headers, `authorization`);
      }
      return options;
    }

    let promise;
    if (this.requiresCredentials(options)) {
      promise = this.spark.credentials.getAuthorization();
    }
    else if (this.requiresClientCredentials(options)) {
      promise = this.spark.credentials.getClientCredentials();
    }

    if (!promise) {
      return options;
    }

    return promise
      .then((authorization) => {
        options.headers.authorization = authorization;
        return options;
      });
  }

  onReject(options, reason) {
    if (this.shouldAttemptReauth(reason, options)) {
      this.spark.logger.info(`auth: received 401, attempting to reauthenticate`);

      if (reason.options.headers) {
        Reflect.deleteProperty(reason.options.headers, `authorization`);
      }

      return this.spark.credentials.authorize({force: true})
        .then(() => {
          return this.replay(options);
        });
    }

    return Promise.reject(reason);
  }

  replay(options) {
    options.replayCount = options.replayCount || 1;

    this.spark.logger.info(`auth: replaying request ${options.replayCount} time`);

    if (options.replayCount > this.spark.config.maxReplayAttempts) {
      this.spark.logger.error(`auth: failed after ${this.spark.config.maxReplayAttempts} replay attempts`);
      return Promise.reject(new Error(`Failed after ${this.spark.config.maxReplayAttempts} replay attempts`));
    }

    return this.spark.request(options);
  }

  requiresCredentials(options) {
    this.spark.logger.warn(`AuthInterceptor: #requiresCredentials should be overridden`);
    if (options.uri.includes(this.spark.config.credentials.oauth.tokenUrl)) {
      return false;
    }

    if (options.uri.includes(this.spark.config.credentials.oauth.authorizeUrl)) {
      return false;
    }

    if (options.uri.includes(this.spark.config.credentials.samlUrl)) {
      return false;
    }

    return true;
  }

  requiresClientCredentials() {
    this.spark.logger.warn(`AuthInterceptor: #requiresClientCredentials should be overridden`);
    return false;
  }

  shouldAttemptReauth(reason, options) {
    if (options && options.shouldRefreshAccessToken === false) {
      return false;
    }

    if (reason.statusCode === 401) {
      return true;
    }

    return false;
  }
}
