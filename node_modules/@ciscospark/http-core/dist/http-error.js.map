{"version":3,"sources":["../src/http-error.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAaA,IAAM,YAAY,2BAAY;AAC5B,WAAS,SAAS,OAAT,CAAiB,GAAjB,EAAsB;;AAE7B,QAAI,OAAO,IAAI,IAAJ,CAFkB;AAG7B,QAAI,mBAAJ,CAH6B;AAI7B,mBAAe,gEAAf;AACE;AACE,YAAI;AACF,iBAAO,KAAK,KAAL,CAAW,IAAX,CAAP,CADE;AAEF,oBAAU,YAAY,IAAZ,CAAV,CAFE;SAAJ,CAIA,OAAO,KAAP,EAAc;AACZ,oBAAU,IAAV,CADY;SAAd;AAGA,cARF;AADF,mBAUE;AACE,kBAAU,YAAY,IAAZ,CAAV,CADF;AAEE,cAFF;AAVF,KAJ6B;;AAmB7B,QAAI,CAAC,OAAD,EAAU;AACZ,gBAAU,KAAK,cAAL,CADE;KAAd;;AAIA,oCAAwB,IAAxB,EAA8B;AAC5B,YAAM;AACJ,oBAAY,KAAZ;AACA,eAAO,IAAP;OAFF;AAIA,mBAAa;AACX,oBAAY,KAAZ;AACA,eAAO,IAAI,WAAJ;OAFT;AAIA,eAAS;AACP,oBAAY,KAAZ;AACA,eAAO,IAAI,OAAJ,IAAe,EAAf;OAFT;AAIA,kBAAY;AACV,oBAAY,KAAZ;AACA,eAAO,IAAI,UAAJ,IAAkB,EAAlB;OAFT;AAIA,gBAAU;AACR,oBAAY,KAAZ;AACA,eAAO,IAAI,QAAJ,IAAgB,EAAhB;OAFT;AAIA,mBAAa;AACX,oBAAY,KAAZ;AACA,eAAO,IAAI,WAAJ,IAAmB,EAAnB;OAFT;AAIA,cAAQ;AACN,oBAAY,KAAZ;AACA,eAAO,IAAI,MAAJ;OAFT;AAIA,WAAK;AACH,oBAAY,KAAZ;AACA,eAAO,IAAI,GAAJ;OAFT;AAIA,kBAAY;AACV,oBAAY,KAAZ;AACA,eAAO,IAAI,UAAJ;OAFT;AAIA,qBAAe;AACb,oBAAY,KAAZ;AACA,eAAO,IAAI,aAAJ;OAFT;AAIA,cAAQ;AACN,oBAAY,KAAZ;AACA,eAAO,IAAI,MAAJ;OAFT;AAIA,YAAM;AACJ,oBAAY,KAAZ;AACA,eAAO,GAAP;OAFF;KA7CF,EAvB6B;;AA0E7B,WAAO,OAAP,CA1E6B;GAAtB;AA4ET,cAAY;AACV,+EADU;GAAZ;AAGA,0BAhF4B;CAAZ,CAAZ;;;;;;;AAwFN,SAAS,WAAT,CAAqB,IAArB,EAA2B;;;AAGzB,MAAM,WAAW,sBAAc,oBAAK,IAAL,wEAAd,CAAX;;;AAHmB,MAMrB,SAAS,MAAT,KAAoB,CAApB,EAAuB;AACzB,WAAO,yBAAe,IAAf,EAAqB,IAArB,EAA2B,CAA3B,CAAP,CADyB;GAA3B;;;AANyB,MAWnB,UAAU,SAAS,CAAT,CAAV;;;AAXmB,MAcrB,OAAO,OAAP,aAAJ,EAAiC;AAC/B,WAAO,YAAY,OAAZ,CAAP,CAD+B;GAAjC;;;AAdyB,SAmBlB,OAAP,CAnByB;CAA3B;;AAuBA,iCAAa,SAAb;AACA,UAAU,YAAV;;kBAEe","file":"http-error.js","sourcesContent":["/**!\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport extendError from 'extend-error';\nimport makeSubTypes from './http-error-subtypes';\nimport {pick} from 'lodash';\n\n/**\n * @class HttpError\n * @extends Error\n */\nconst HttpError = extendError({\n  parseFn: function parseFn(res) {\n    /* eslint complexity: [0] */\n    let body = res.body;\n    let message;\n    switch (typeof body) {\n      case `string`:\n        try {\n          body = JSON.parse(body);\n          message = parseObject(body);\n        }\n        catch (error) {\n          message = body;\n        }\n        break;\n      case `object`:\n        message = parseObject(body);\n        break;\n    }\n\n    if (!message) {\n      message = this.defaultMessage;\n    }\n\n    Object.defineProperties(this, {\n      body: {\n        enumerable: false,\n        value: body\n      },\n      httpVersion: {\n        enumerable: false,\n        value: res.httpVersion\n      },\n      headers: {\n        enumerable: false,\n        value: res.headers || {}\n      },\n      rawHeaders: {\n        enumerable: false,\n        value: res.rawHeaders || []\n      },\n      trailers: {\n        enumerable: false,\n        value: res.trailers || {}\n      },\n      rawTrailers: {\n        enumerable: false,\n        value: res.rawTrailers || []\n      },\n      method: {\n        enumerable: false,\n        value: res.method\n      },\n      url: {\n        enumerable: false,\n        value: res.url\n      },\n      statusCode: {\n        enumerable: false,\n        value: res.statusCode\n      },\n      statusMessage: {\n        enumerable: false,\n        value: res.statusMessage\n      },\n      socket: {\n        enumerable: false,\n        value: res.socket\n      },\n      _res: {\n        enumerable: false,\n        value: res\n      }\n    });\n\n    return message;\n  },\n  properties: {\n    defaultMessage: `An error was received while trying to fulfill the request`\n  },\n  subTypeName: `HttpError`\n});\n\n/**\n * @param {object} body\n * @private\n * @returns {string}\n */\nfunction parseObject(body) {\n  // TODO make plausible error string list configurable\n  // Search body for common names of error strings\n  const messages = Object.values(pick(body, `message`, `error`, `errorString`, `response`, `errorResponse`, `msg`));\n\n  // If no error candidate was found, stringify the entire body\n  if (messages.length === 0) {\n    return JSON.stringify(body, null, 2);\n  }\n\n  // Assume the first key found was the error explanation\n  const message = messages[0];\n\n  // If the explanation is an object, recurse and try again\n  if (typeof message === `object`) {\n    return parseObject(message);\n  }\n\n  // Return the first key\n  return message;\n}\n\n\nmakeSubTypes(HttpError);\nHttpError.makeSubTypes = makeSubTypes;\n\nexport default HttpError;\n"]}