{"version":3,"sources":["../src/retry.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;kBAsBwB;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAT,SAAS,aAAT,CAAuB,EAAvB,EAA2B,OAA3B,EAAoC;AACjD,MAAI,CAAC,0BAAW,EAAX,CAAD,EAAiB;AACnB,UAAM,IAAI,KAAJ,2BAAN,CADmB;GAArB;;AAIA,YAAU,WAAW,EAAX,CALuC;;AAOjD,0BAAS,OAAT,EAAkB;AAChB,aAAS,IAAT;AACA,WAAO,CAAP;AACA,iBAAa,CAAb;GAHF,EAPiD;;AAajD,MAAI,2BAAJ,CAbiD;AAcjD,MAAI,CAAC,QAAQ,OAAR,EAAiB;AACpB,sBAAkB;AAChB,oBAAc,CAAd;AACA,gBAAU,CAAV;KAFF,CADoB;GAAtB,MAMK;AACH,sBAAkB;AAChB,oBAAc,QAAQ,KAAR;AACd,gBAAU,QAAQ,QAAR;KAFZ,CADG;GANL;;AAaA,SAAO,SAAS,KAAT,GAAwB;;;sCAAN;;KAAM;;AAC7B,QAAM,UAAU,0BAAV,CADuB;AAE7B,QAAM,UAAU,sBAAY,UAAC,OAAD,EAAU,MAAV,EAAqB;;;;AAI/C,UAAM,OAAO,kBAAQ,IAAR,CACX,UAAC,EAAD,EAAQ;AACN,YAAM,UAAU,4BAAoB,EAApB,EAAwB,IAAxB,CAAV,CADA;;AAGN,YAAI,0BAAW,QAAQ,EAAR,CAAf,EAA4B;AAC1B,kBAAQ,EAAR,aAAuB,QAAQ,IAAR,CAAa,IAAb,CAAkB,OAAlB,aAAvB,EAD0B;AAE1B,kBAAQ,EAAR,oBAA8B,QAAQ,IAAR,CAAa,IAAb,CAAkB,OAAlB,oBAA9B,EAF0B;AAG1B,kBAAQ,EAAR,sBAAgC,QAAQ,IAAR,CAAa,IAAb,CAAkB,OAAlB,sBAAhC,EAH0B;SAA5B;;AAMA,eAAO,QACJ,IADI,CACC,UAAC,GAAD,EAAS;AACb,aAAG,IAAH,EAAS,GAAT,EADa;SAAT,CADD,CAIJ,KAJI,CAIE,UAAC,MAAD,EAAY;AACjB,cAAI,CAAC,MAAD,EAAS;AACX,qBAAS,IAAI,KAAJ,6DAAT,CADW;WAAb;AAGA,aAAG,MAAH,EAJiB;SAAZ,CAJT,CATM;OAAR,EAoBA,UAAC,GAAD,EAAM,GAAN,EAAc;AACZ,YAAI,GAAJ,EAAS;AACP,iBAAO,OAAO,GAAP,CAAP,CADO;SAAT;;AAIA,gBAAQ,GAAR,EALY;OAAd,CArBI,CAJyC;;AAkC/C,WAAK,WAAL,CAAiB,IAAI,kBAAQ,mBAAR,CAA4B,eAAhC,CAAjB,EAlC+C;AAmC/C,UAAI,QAAQ,WAAR,EAAqB;AACvB,aAAK,SAAL,CAAe,QAAQ,WAAR,GAAsB,CAAtB,CAAf,CADuB;OAAzB;;AAIA,WAAK,KAAL,GAvC+C;KAArB,CAAtB,CAFuB;;AA4C7B,YAAQ,EAAR,GAAa,SAAS,EAAT,CAAY,GAAZ,EAAiB,QAAjB,EAA2B;AACtC,cAAQ,EAAR,CAAW,GAAX,EAAgB,QAAhB,EADsC;AAEtC,aAAO,OAAP,CAFsC;KAA3B,CA5CgB;;AAiD7B,WAAO,OAAP,CAjD6B;GAAxB,CA3B0C;CAApC","file":"retry.js","sourcesContent":["/**!\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport backoff from 'backoff';\nimport {defaults, isFunction} from 'lodash';\nimport {EventEmitter} from 'events';\n\n/**\n * Makes a promise-returning method retryable according to the specified backoff\n * pattern\n * @param {Function} fn\n * @param {Object} options\n * @param {boolean} options.backoff\n * @param {number} options.delay\n * @param {number} options.initialDelay\n * @param {number} options.maxAttempts\n * @param {number} options.maxDelay\n *\n * @returns {Function}\n */\nexport default function makeRetryable(fn, options) {\n  if (!isFunction(fn)) {\n    throw new Error(`\\`fn\\` must be a function`);\n  }\n\n  options = options || {};\n\n  defaults(options, {\n    backoff: true,\n    delay: 1,\n    maxAttempts: 3\n  });\n\n  let strategyOptions;\n  if (!options.backoff) {\n    strategyOptions = {\n      initialDelay: 1,\n      maxDelay: 1\n    };\n  }\n  else {\n    strategyOptions = {\n      initialDelay: options.delay,\n      maxDelay: options.maxDelay\n    };\n  }\n\n  return function retry(...args) {\n    const emitter = new EventEmitter();\n    const promise = new Promise((resolve, reject) => {\n      // backoff.call is not Function.prototype.call; it's an unfortunate naming\n      // collision.\n      /* eslint prefer-reflect: [0] */\n      const call = backoff.call(\n        (cb) => {\n          const promise = Reflect.apply(this, fn, args);\n\n          if (isFunction(promise.on)) {\n            promise.on(`progress`, emitter.emit.bind(emitter, `progress`));\n            promise.on(`upload-progress`, emitter.emit.bind(emitter, `upload-progress`));\n            promise.on(`download-progress`, emitter.emit.bind(emitter, `download-progress`));\n          }\n\n          return promise\n            .then((res) => {\n              cb(null, res);\n            })\n            .catch((reason) => {\n              if (!reason) {\n                reason = new Error(`retryable method failed without providing an error object`);\n              }\n              cb(reason);\n            });\n        },\n        (err, res) => {\n          if (err) {\n            return reject(err);\n          }\n\n          resolve(res);\n        }\n      );\n\n      call.setStrategy(new backoff.ExponentialStrategy(strategyOptions));\n      if (options.maxAttempts) {\n        call.failAfter(options.maxAttempts - 1);\n      }\n\n      call.start();\n    });\n\n    promise.on = function on(key, callback) {\n      emitter.on(key, callback);\n      return promise;\n    };\n\n    return promise;\n  };\n}\n"]}